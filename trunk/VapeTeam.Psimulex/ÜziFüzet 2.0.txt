Csak, hgoy ez is lehessen.

2008.09.02.

Hiba :
"i++" -> i ismer fel (ez nemjó)
"++i++"	-> (++ (i ++)) (ez jó)

Változók, Identifier használatánál nem mûködik a móka. :
a+b+c -> a lesz

Minden kulcsszót, egyebet felvettem Lexikai szabálynak. A szétválasztás után lehet a maradékot megcsinálni.
... Amit nem bírtma megcsinálni.

A tesztkörnyezetbeni változtatások : 
- Ha a save and closera kattolsz, akkor ment bezárás elõtt és
következõ megnyitáskór a mentett hozza elõ + archivál mindent,
ha netán egy jó teszteset kéne újra, még jólehet.
- A szintax highlightot bekapcsoltam, lényegében ezzel :)
- F5,F6,F7,F8 -ra fordít ( Simulexbõl néztem ki, hgoy csináltad, ezzel si újat tanultam :) )

--------------------------------

2008.09.02. 22:45 - pody

1. Elsõ megjegyzés, a grammar fájllal kapcsolatban: minek elnevezni minden tokent? Fõleg a P:'+' és M:'-' és egyéb formációk nem túl szimpik számomra.

2. Szintén a grammarhez, muszáj a nagy kezdõbetûs és nagybetûs neveket mindenhova felvenni? Lehet hogy célszerûbb volna írni egy saját TokenStream-et, ami ha nem character vagy string literált olvas, akkor ToLower-t hív az aktuális karakterre.

3. Az a+b+c problémát egyszerû volt javítani. Nem is értem, hogy ha sikeresen másoltad a nyelvtan egy részét, akkor miért variálsz bele ilyet:

expression
	:	assignment
	|	conditionalOrExpression
	;
assignment
	:	leftValue (assignmentOperator^ expression)?
	
Gondolom ránézésre te is látod, hogy minden "leftvalue" jó egy expressionnek, mert az assignment nyelvtani szabály farka opcionális lett. A módosított nyelvtant bekommitáltam.

Ha van még valami gond írj. Most eszek és még talán Core-ozok.

2008.09.03. 04:00 - vari

1. Elõzõ verzióban is el volt nevezve, igaz teljes nevük volt. Rövidítettem.
a) Nelegyenek elnevezve ?
b) Rendes nevük legyen ?

Mindkettõ könnyen kivitelezhetõ. Mond, milyen lenne szebb, praktikusabb olyan lesz.

2. Alapvetõen igazad van. Mivel nagyon hamar megvolt, azért kopogtam be, mint egy megoldás a témára.
   Igazából a csupa kisbetû, ahogy mindenhol van is tökéletes lenne. Gondoltam kivenni pillanatok alatt megvan.
   
3. Az elgondolás amiért ilyen lett, hogy lehessen vele csupáncsak a.a(); parancsot írni.
   Igazából átsíklottam mindannyiszor felette, amikro kerestem hol a hiba.
   A mellékelt JAVA minta és a régi Simulex-es .g -t ötvöztem. Próbáltam kicsit letisztítani.
   
Változások :
-	Átírtam normális nevûekre az idétlen rövidítéseimet. :)
Azért is neveztem el mindent, hogy majd szépen lehessen PsimulexLexer.Pluss hivatkozni. Persze tudom, ez is megoldható ezermásféleképp,
de ez volt szimpi. Ha nem nevezem el, akor az ANTLR nevezi el generált névvel, gondoltam, akkor legyen szép.
-	Kijavítottam még egy apró hibát és most elméletielg a teljes Expression szekció mûködik. ( Teszteltem )
-	Szelektorok, struktúra definiálás, globális változók, függvény definiálás tesztelve és mûködik
-	A vezérlési szerkezeteket nem teszteltem agyon még, de egyébként azok is mennek.
	Azaz, elméletielg az egész megy.

#-#	Lényegében véve, elsõ nekifutásra összeállt a nyelvtan.
	2 dolog van vele a köv körre : 
		° Lambdakalkulus ezt még kicsit tanulmányozgatom, mûvelõdök, de már van elképzelés.
		° A Tree Parser, ezügyben, ha tudsz segíts légyszíves.
		Nekem egy elképzelésem van, amit 2 fájlban "tudhatnék" megvalósítani, erre látam mintát.
		
		
2008.09.03. 14:30 - vari

1. Lambda belemûtve.
	// Anomália. Egyenlõre nemtudom miért. A (int)
	id(int) = a => a;
	
Igazából, lehet, hogy nem is kell. Sõt. Fölösleges 2 helyen jelezni a típust.
Javaslatom a C# -os analógiához képest, hogy a fv pointernél cska visszatérési érték típusát lehessen emghatározni, 
a paraméterekét a lambda kifejezésben.

PL így :
int add = (int a, int b) => a + b;
Ha szerinted jó lesz így, szólj és ilyenre csinálom
else megkell keresni mi a baja :)

2008.09.04. 1:10 - vari

1.

- Kicsit átdolgoztam a nyelvtant több ponton.
- Kivettem pár feleslegesnek tûnõ átvezetõ szabályt, módosítottam pár dolgot.
- Volt pár dolog, ami nem a saját szekciócskájában volt, azokon is pakolásztam picit.
- Volt egy-két dolog, amit átkereszteltem, bár nekem is fáj néha, ahogy elnevezem, de nincs jobb ötletem.

Ez de szép már ! :

import "asd";

struct record	{	int i = 10;	string s = "asd";	bool b = true;	char c = 's';	}

int i;
string s = "sanyi";

int main(int i)
{
	for(int i = 10; i < 10; i++)
		i++;
		
	while(a==b)
	{	string s = "as";	}
	
	f = a => a + a;
	int f = (bool b, char c) => b % c;
		
	id = a => 
	{
		int i;
		a+b+c-d--;
		return a;
	};
	
	id = a => a;
	
	l--;
}

És ez mind megy.

2.

Elkészítettem egy PsiAST vázlatot. Egy alapnak nemrossz.
Vízionáltam még pár statikus fv-t amit majd a fa építésekor tudunk használni.

Van még egy érvem a minden elnevezése mellet : Amikor az ANTL ToTreeString() -je 
megcsinálja azt az eredmény stringet és valmi hiba lép fel,, akkor a hiányzó token számát adja meg.
Igen ám, de ha én nem adtam neki nevet, akkor T_83 les za token neve és mégcsak ASCI kódra se stimmel a dolog.
Persze ennek a jelentõsége zéróra fog csökkenni, nohde akkor is egy szempont.

Még megsasolom mit kommitáltál, csorgó nyállal oszt nekem is szunya.
Holnap Andi jön és 6 ig ittlesz kb. Szóval este leszek.
HA van energiád magyarázni -- én meg felfogom -- :) akor nekitudok állni ennek a résznek is.
Izgin hangzik. :)

V

2008.09.06 23:00 - Vari

Felmerült pár dolog :
1) FV viszsatérési értéke lehet e FunkcióPointer típus ? ( Jelenleg igen )
2) Rekord mezõje csak meghatározott méretû tömb/mátrix lehet ? ( Jelenleg igen. int[10] i; lehetne int[] i; )
3) FV visszatérési értéke csak meghatározott méretõ tömb/mátrix lehet ? ( Jelenleg igen )
4) FV visszatérési értéke lehet funkció pointer ? ( Jelnleg igen )

Megjegzés : Még pár virtuális csúcsot szeretnék beszúrkálni.
Alapvetõen szeretnék egy egyensúlyt megtartani, a minél kevesebb csúcs 
és a minél egyszerûbb fordíthatóság
valmint a minél "szebb" szintax fa. 
( Azaz ránézel és egyértelmûen látszik midne rajta. Ne kelljen bogarászni. )
Kiváncis vagyok a véleményedre, az eddigiekrõl, hogy ne menjek el nem megfellõ irányba. :)

Barkácsoltam valmit :)
Próbáld ki a lentebbi kóddal,			F5, Majd F8

Kód:
----

import "valami.psi";
import "mégValmi.psi";
import "ÚjfentValami";

struct record	{	string s = "asd";	bool b = true;	char c;	func<List[,]>[1,1] l;	}
struct s {	int z = "10";	}

int i;
func<int[,]>[1,1] l;
string s = "sanyi";

int main(int i)
{
	for(int i = 1; i < 10; i++)
		i++;
		
	while(a==b)
	{	string s;	}
	
	fv = ( fa, fb ) => a + a;
	
	f = (bool b, char c) => b % c;
		
	id = a => 
	{
		int i;
		a+b+c-d--;
		return a;
	};
	add(10+10,20*"as");
	
	id = a => a;

	l--;
}

list add(int[1,1] & a, int b)
{
	return a + b;
}