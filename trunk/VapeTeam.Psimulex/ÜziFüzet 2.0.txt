Csak, hgoy ez is lehessen.

2008.09.02.

Hiba :
"i++" -> i ismer fel (ez nemjó)
"++i++"	-> (++ (i ++)) (ez jó)

Változók, Identifier használatánál nem mûködik a móka. :
a+b+c -> a lesz

Minden kulcsszót, egyebet felvettem Lexikai szabálynak. A szétválasztás után lehet a maradékot megcsinálni.
... Amit nem bírtma megcsinálni.

A tesztkörnyezetbeni változtatások : 
- Ha a save and closera kattolsz, akkor ment bezárás elõtt és
következõ megnyitáskór a mentett hozza elõ + archivál mindent,
ha netán egy jó teszteset kéne újra, még jólehet.
- A szintax highlightot bekapcsoltam, lényegében ezzel :)
- F5,F6,F7,F8 -ra fordít ( Simulexbõl néztem ki, hgoy csináltad, ezzel si újat tanultam :) )

--------------------------------

2008.09.02. 22:45 - pody

1. Elsõ megjegyzés, a grammar fájllal kapcsolatban: minek elnevezni minden tokent? Fõleg a P:'+' és M:'-' és egyéb formációk nem túl szimpik számomra.

2. Szintén a grammarhez, muszáj a nagy kezdõbetûs és nagybetûs neveket mindenhova felvenni? Lehet hogy célszerûbb volna írni egy saját TokenStream-et, ami ha nem character vagy string literált olvas, akkor ToLower-t hív az aktuális karakterre.

3. Az a+b+c problémát egyszerû volt javítani. Nem is értem, hogy ha sikeresen másoltad a nyelvtan egy részét, akkor miért variálsz bele ilyet:

expression
	:	assignment
	|	conditionalOrExpression
	;
assignment
	:	leftValue (assignmentOperator^ expression)?
	
Gondolom ránézésre te is látod, hogy minden "leftvalue" jó egy expressionnek, mert az assignment nyelvtani szabály farka opcionális lett. A módosított nyelvtant bekommitáltam.

Ha van még valami gond írj. Most eszek és még talán Core-ozok.

2008.09.03. 04:00 - vari

1. Elõzõ verzióban is el volt nevezve, igaz teljes nevük volt. Rövidítettem.
a) Nelegyenek elnevezve ?
b) Rendes nevük legyen ?

Mindkettõ könnyen kivitelezhetõ. Mond, milyen lenne szebb, praktikusabb olyan lesz.

2. Alapvetõen igazad van. Mivel nagyon hamar megvolt, azért kopogtam be, mint egy megoldás a témára.
   Igazából a csupa kisbetû, ahogy mindenhol van is tökéletes lenne. Gondoltam kivenni pillanatok alatt megvan.
   
3. Az elgondolás amiért ilyen lett, hogy lehessen vele csupáncsak a.a(); parancsot írni.
   Igazából átsíklottam mindannyiszor felette, amikro kerestem hol a hiba.
   A mellékelt JAVA minta és a régi Simulex-es .g -t ötvöztem. Próbáltam kicsit letisztítani.
   
Változások :
-	Átírtam normális nevûekre az idétlen rövidítéseimet. :)
Azért is neveztem el mindent, hogy majd szépen lehessen PsimulexLexer.Pluss hivatkozni. Persze tudom, ez is megoldható ezermásféleképp,
de ez volt szimpi. Ha nem nevezem el, akor az ANTLR nevezi el generált névvel, gondoltam, akkor legyen szép.
-	Kijavítottam még egy apró hibát és most elméletielg a teljes Expression szekció mûködik. ( Teszteltem )
-	Szelektorok, struktúra definiálás, globális változók, függvény definiálás tesztelve és mûködik
-	A vezérlési szerkezeteket nem teszteltem agyon még, de egyébként azok is mennek.
	Azaz, elméletielg az egész megy.

#-#	Lényegében véve, elsõ nekifutásra összeállt a nyelvtan.
	2 dolog van vele a köv körre : 
		° Lambdakalkulus ezt még kicsit tanulmányozgatom, mûvelõdök, de már van elképzelés.
		° A Tree Parser, ezügyben, ha tudsz segíts légyszíves.
		Nekem egy elképzelésem van, amit 2 fájlban "tudhatnék" megvalósítani, erre látam mintát.
		
		
2008.09.03. 14:30 - vari

1. Lambda belemûtve.
	// Anomália. Egyenlõre nemtudom miért. A (int)
	id(int) = a => a;
	
Igazából, lehet, hogy nem is kell. Sõt. Fölösleges 2 helyen jelezni a típust.
Javaslatom a C# -os analógiához képest, hogy a fv pointernél cska visszatérési érték típusát lehessen emghatározni, 
a paraméterekét a lambda kifejezésben.

PL így :
int add = (int a, int b) => a + b;
Ha szerinted jó lesz így, szólj és ilyenre csinálom
else megkell keresni mi a baja :)

2008.09.04. 1:10 - vari

1.

- Kicsit átdolgoztam a nyelvtant több ponton.
- Kivettem pár feleslegesnek tûnõ átvezetõ szabályt, módosítottam pár dolgot.
- Volt pár dolog, ami nem a saját szekciócskájában volt, azokon is pakolásztam picit.
- Volt egy-két dolog, amit átkereszteltem, bár nekem is fáj néha, ahogy elnevezem, de nincs jobb ötletem.

Ez de szép már ! :

import "asd";

struct record	{	int i = 10;	string s = "asd";	bool b = true;	char c = 's';	}

int i;
string s = "sanyi";

int main(int i)
{
	for(int i = 10; i < 10; i++)
		i++;
		
	while(a==b)
	{	string s = "as";	}
	
	f = a => a + a;
	int f = (bool b, char c) => b % c;
		
	id = a => 
	{
		int i;
		a+b+c-d--;
		return a;
	};
	
	id = a => a;
	
	l--;
}

És ez mind megy.

2.

Elkészítettem egy PsiAST vázlatot. Egy alapnak nemrossz.
Vízionáltam még pár statikus fv-t amit majd a fa építésekor tudunk használni.

Van még egy érvem a minden elnevezése mellet : Amikor az ANTL ToTreeString() -je 
megcsinálja azt az eredmény stringet és valmi hiba lép fel,, akkor a hiányzó token számát adja meg.
Igen ám, de ha én nem adtam neki nevet, akkor T_83 les za token neve és mégcsak ASCI kódra se stimmel a dolog.
Persze ennek a jelentõsége zéróra fog csökkenni, nohde akkor is egy szempont.

Még megsasolom mit kommitáltál, csorgó nyállal oszt nekem is szunya.
Holnap Andi jön és 6 ig ittlesz kb. Szóval este leszek.
HA van energiád magyarázni -- én meg felfogom -- :) akor nekitudok állni ennek a résznek is.
Izgin hangzik. :)

V

2008.09.06 23:00 - Vari

Felmerült pár dolog :
1) FV viszsatérési értéke lehet e FunkcióPointer típus ? ( Jelenleg igen )
2) Rekord mezõje csak meghatározott méretû tömb/mátrix lehet ? ( Jelenleg igen. int[10] i; lehetne int[] i; )
3) FV visszatérési értéke csak meghatározott méretõ tömb/mátrix lehet ? ( Jelenleg igen )

Megjegzés : Még pár virtuális csúcsot szeretnék beszúrkálni.
Alapvetõen szeretnék egy egyensúlyt megtartani, a minél kevesebb csúcs 
és a minél egyszerûbb fordíthatóság
valmint a minél "szebb" szintax fa. 
( Azaz ránézel és egyértelmûen látszik midne rajta. Ne kelljen bogarászni. )
Kiváncis vagyok a véleményedre, az eddigiekrõl, hogy ne menjek el nem megfellõ irányba. :)

Barkácsoltam valmit :)
Próbáld ki a lentebbi kóddal,			F5, Majd F8

Kód:
----

import "valami.psi";
import "mégValmi.psi";
import "ÚjfentValami";

struct record	{	string s = "asd";	bool b = true;	char c;	func<List[,]>[1,1] l;	}
struct s {	int z = "10";	}

int i;
func<int[,]>[1,1] l;
string s = "sanyi";

int main(int i)
{
	for(int i = 1; i < 10; i++)
		i++;
		
	while(a==b)
	{	string s;	}
	
	fv = ( fa, fb ) => a + a;
	
	f = (bool b, char c) => b % c;
		
	id = a => 
	{
		int i;
		a+b+c-d--;
		return a;
	};
	add(10+10,20*"as");
	
	id = a => a;

	l--;
}

list add(int[1,1] & a, int b)
{
	return a + b;
}


2008.09.22 01:00 - Vari

- A View Program String Gomb alatt van teszt Eset Generálás.
Az aktuális Programhoz generál egy az egyben másolható teszt esetet.
- Mennek az Escape Characterek is ! 

Ami nemmegy: char ch = '\n';
Erre nem emel sort, mert ugye \r\n kéne.
Lehet, hogy, felveszem a nyelvtanba a \r -t is, de igazából nincs szerepe.

- Fordul a : VarInit,Vardec,intliteral,charliteral,stringliteral,functionvcall.


2008. Szeptember 28. - Vari

Megrendelõ Lista :-)
( A Fontossági csoportok, csak kb-ra vannak, inkább az egészet egybe nézd. )

Fontosabb :
-----------

- Szeretnék olyaít, hgoy a reflectionos dolog tudjon referencia szerint mûködni (SWAP fv)
- A felhasználó álltal definiált FV -ek beröcentése ( Írtam rá pár osztályt )

Közepesen Fontos :
------------------

- Rekordok Beröccentése
- Paraméterszám alapján túlterhelhetõ fv -ek

Kevésbé fontos :
----------------

- Több Dimenziós tömb, Asszociatív tömb


Egyéb Bug -ok :
--------------

- Mit lehet csinálni azzal, hogy az ANTLR nemszereti, ha a kulcsszavakat, használjuk fv névnek, vagy változónévnek ?
  Ha van valami kulturált ötleted rá, akor vesed elõ.
  Itt pl a Sor -nél találkoztam vele, mert akartam In,Out fv-eket csinálni és az In az fáj neki.
  De persze ez nem nagy katasztrófa, ezért alacsony fontosságú.
  
  
Egyéb :
-------

- Lehetne Attribútumokkal megjelölni, hogy melyik tagfüggvény reflektálódjon kifele, márha van olyan, amit nem akarunk "kiengedni".
  Egyébként meg nem tudom mire gondoltál, hogy az Add() menjen, de azt is meglehet Attribútumokkal barkácsolni valahogy.
  Jah kiengedni pl az Add() Substract() meg ezeket lenne felesleges lényegében, persze ártani nem ártó.
  Csak a 5 tag : Add,Remove,Clear,IsEmpty,Count azt ugye mindenhova beletenném, emg legyne már következetes.
  Most Az Add helyett mindenhol Insertet írok, hogy könnyebb elygen utólag refaktorálni.
  
- Clone téma:
  A Clone() most úgy mûködik, hgoyaz érték típusokat másolja, a referencia típusokat nem.
  Viszont van pár eset, amikor meg szûkség lenne arra, hgoy másoljuk õket. Pl.
  Queue q; Queue p;
  p + q; // Ez már megy, konkatenál.
  Itt a p-n végrehajtódi ka mósosulás mintha p = p + q; lenne.
  Mert a Clone() csak az érték típusokat Klónozza.
  
  Javaslatom, hogy belsõ ahsználatra legyen 2 féle Clone() az egyik mindet klónoz ( Ezt használják a parancsobjektumok )
  A másik pedig csak az érték típusokat, ahgoy eddig.
  
  Illetve legyen lehetõség rá, PSimulex kódból is klónozni, ahol ere szûkség van.
  



2008 Október 2. - Vari

Van egy ötletem ehhez a referencia nem referencia témára. Mi lenne ha bevezetnénk 2 kulcs szót. Lehetne & jel is, vagy mind akettõ is a jelölésére. Most én elnevezem ref és val  -nak a két kulcs szót. Semmi mást nem csinálnak, mint az így megjelölt változót a jelölt módon dobnéá a verembe.
Ugye érték típust mint int , char stb defaultból érték szeritn míg a referencia típusokat referencia szerint. Persze ezt sem teljesen, emrt az értékadás mindenhol érték szerint menne, mert ez az amire a legtöbb helyen szûkség van. Viszont nagyon kényelmes lenne, ha ezt ezzel a 2 kulcs szóva (vagy más ugyanezen célú jellel) ezt felül lehetne bírálni.

Konkrétan amikor pl a szintfolytonos bejáráûsnál akarun kegy sorbapakolni akor referencia szerint akarunk pakolni.
De mondjuk ha mi másolni akarnánk akkor csak annyi kéne ínri hogy (val Tree.Left)

Most végiggondolva értelmesebbnek tûnik egy Psimulex kódból hívható .Clone() fv :)

De azért itthagyom hátha ihlet más felhasználást is.

Jah a másik dolog a & jel mellé bevezetem a nyelvtanba a ref kulcsszót is.
Ilyen feketefélék nagyon idegenkednek az ilyen operátoroktól és a ref egy kicsit bizalomgerjesztõbb lehet számukra.
Ugyan arra fordulna, csak egy kis szöszsenet.